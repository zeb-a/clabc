import{G as e,b as t,i as r,M as i,K as n,z as o,$ as u,T as s,ai as a,R as l,w as c,_ as d,p}from"./index-svZ-RVFa.js";import{F as f}from"./Filter-CMWQ1Zib.js";import"./ui-vendor-EWGJrgPd.js";import"./react-vendor-ChpS9P31.js";import"./chart-vendor-0rydfco4.js";import"./editor-vendor-DxsG0AYC.js";import"./utils-vendor-Ba_uBsT8.js";import"./docx-BFhGZ45W.js";var h="struct GlobalFilterUniforms {\n  uInputSize: vec4<f32>,\n  uInputPixel: vec4<f32>,\n  uInputClamp: vec4<f32>,\n  uOutputFrame: vec4<f32>,\n  uGlobalFrame: vec4<f32>,\n  uOutputTexture: vec4<f32>,\n};\n\n@group(0) @binding(0) var <uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler: sampler;\n\nstruct VSOutput {\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv: vec2<f32>\n};\n\nfn filterVertexPosition(aPosition: vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0 * gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord(aPosition: vec2<f32>) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition: vec2<f32>,\n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n) -> @location(0) vec4<f32> {\n    return textureSample(uTexture, uSampler, uv);\n}\n";class x extends f{constructor(){super({gpuProgram:e.from({vertex:{source:h,entryPoint:"mainVertex"},fragment:{source:h,entryPoint:"mainFragment"},name:"passthrough-filter"}),glProgram:t.from({vertex:"in vec2 aPosition;\nout vec2 vTextureCoord;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n",fragment:"in vec2 vTextureCoord;\nout vec4 finalColor;\nuniform sampler2D uTexture;\nvoid main() {\n    finalColor = texture(uTexture, vTextureCoord);\n}\n",name:"passthrough-filter"})})}}class m{constructor(e){this._renderer=e}push(e,t,r){this._renderer.renderPipes.batch.break(r),r.add({renderPipeId:"filter",canBundle:!1,action:"pushFilter",container:t,filterEffect:e})}pop(e,t,r){this._renderer.renderPipes.batch.break(r),r.add({renderPipeId:"filter",action:"popFilter",canBundle:!1})}execute(e){"pushFilter"===e.action?this._renderer.filter.push(e):"popFilter"===e.action&&this._renderer.filter.pop()}destroy(){this._renderer=null}}m.extension={type:[r.WebGLPipes,r.WebGPUPipes,r.CanvasPipes],name:"filter"};const g=new i;const T=new a({attributes:{aPosition:{buffer:new Float32Array([0,0,1,0,1,1,0,1]),format:"float32x2",stride:8,offset:0}},indexBuffer:new Uint32Array([0,1,2,0,2,3])});class b{constructor(){this.skip=!1,this.inputTexture=null,this.backTexture=null,this.filters=null,this.bounds=new d,this.container=null,this.blendRequired=!1,this.outputRenderSurface=null,this.globalFrame={x:0,y:0,width:0,height:0},this.firstEnabledIndex=-1,this.lastEnabledIndex=-1}}class _{constructor(e){this._filterStackIndex=0,this._filterStack=[],this._filterGlobalUniforms=new n({uInputSize:{value:new Float32Array(4),type:"vec4<f32>"},uInputPixel:{value:new Float32Array(4),type:"vec4<f32>"},uInputClamp:{value:new Float32Array(4),type:"vec4<f32>"},uOutputFrame:{value:new Float32Array(4),type:"vec4<f32>"},uGlobalFrame:{value:new Float32Array(4),type:"vec4<f32>"},uOutputTexture:{value:new Float32Array(4),type:"vec4<f32>"}}),this._globalFilterBindGroup=new o({}),this.renderer=e}get activeBackTexture(){return this._activeFilterData?.backTexture}push(e){const t=this.renderer,r=e.filterEffect.filters,i=this._pushFilterData();i.skip=!1,i.filters=r,i.container=e.container,i.outputRenderSurface=t.renderTarget.renderSurface;const n=t.renderTarget.renderTarget.colorTexture.source,o=n.resolution,u=n.antialias;if(r.every(e=>!e.enabled))return void(i.skip=!0);const s=i.bounds;if(this._calculateFilterArea(e,s),this._calculateFilterBounds(i,t.renderTarget.rootViewPort,u,o,1),i.skip)return;const a=this._getPreviousFilterData(),l=this._findFilterResolution(o);let c=0,d=0;a&&(c=a.bounds.minX,d=a.bounds.minY),this._calculateGlobalFrame(i,c,d,l,n.width,n.height),this._setupFilterTextures(i,s,t,a)}generateFilteredTexture({texture:e,filters:t}){const r=this._pushFilterData();this._activeFilterData=r,r.skip=!1,r.filters=t;const i=e.source,n=i.resolution,o=i.antialias;if(t.every(e=>!e.enabled))return r.skip=!0,e;const a=r.bounds;if(a.addRect(e.frame),this._calculateFilterBounds(r,a.rectangle,o,n,0),r.skip)return e;const l=n;this._calculateGlobalFrame(r,0,0,l,i.width,i.height),r.outputRenderSurface=u.getOptimalTexture(a.width,a.height,r.resolution,r.antialias),r.backTexture=s.EMPTY,r.inputTexture=e;this.renderer.renderTarget.finishRenderPass(),this._applyFiltersToTexture(r,!0);const c=r.outputRenderSurface;return c.source.alphaMode="premultiplied-alpha",c}pop(){const e=this.renderer,t=this._popFilterData();t.skip||(e.globalUniforms.pop(),e.renderTarget.finishRenderPass(),this._activeFilterData=t,this._applyFiltersToTexture(t,!1),t.blendRequired&&u.returnTexture(t.backTexture),u.returnTexture(t.inputTexture))}getBackTexture(e,t,r){const i=e.colorTexture.source._resolution,n=u.getOptimalTexture(t.width,t.height,i,!1);let o=t.minX,s=t.minY;r&&(o-=r.minX,s-=r.minY),o=Math.floor(o*i),s=Math.floor(s*i);const a=Math.ceil(t.width*i),l=Math.ceil(t.height*i);return this.renderer.renderTarget.copyToTexture(e,n,{x:o,y:s},{width:a,height:l},{x:0,y:0}),n}applyFilter(e,t,r,i){const n=this.renderer,o=this._activeFilterData,u=o.outputRenderSurface===r,s=n.renderTarget.rootRenderTarget.colorTexture.source._resolution,a=this._findFilterResolution(s);let l=0,c=0;if(u){const e=this._findPreviousFilterOffset();l=e.x,c=e.y}this._updateFilterUniforms(t,r,o,l,c,a,u,i);const d=e.enabled?e:this._getPassthroughFilter();this._setupBindGroupsAndRender(d,t,n)}calculateSpriteMatrix(e,t){const r=this._activeFilterData,n=e.set(r.inputTexture._source.width,0,0,r.inputTexture._source.height,r.bounds.minX,r.bounds.minY),o=t.worldTransform.copyTo(i.shared),u=t.renderGroup||t.parentRenderGroup;return u&&u.cacheToLocalTransform&&o.prepend(u.cacheToLocalTransform),o.invert(),n.prepend(o),n.scale(1/t.texture.orig.width,1/t.texture.orig.height),n.translate(t.anchor.x,t.anchor.y),n}destroy(){this._passthroughFilter?.destroy(!0),this._passthroughFilter=null}_getPassthroughFilter(){return this._passthroughFilter??(this._passthroughFilter=new x),this._passthroughFilter}_setupBindGroupsAndRender(e,t,r){if(r.renderPipes.uniformBatch){const e=r.renderPipes.uniformBatch.getUboResource(this._filterGlobalUniforms);this._globalFilterBindGroup.setResource(e,0)}else this._globalFilterBindGroup.setResource(this._filterGlobalUniforms,0);this._globalFilterBindGroup.setResource(t.source,1),this._globalFilterBindGroup.setResource(t.source.style,2),e.groups[0]=this._globalFilterBindGroup,r.encoder.draw({geometry:T,shader:e,state:e._state,topology:"triangle-list"}),r.type===l.WEBGL&&r.renderTarget.finishRenderPass()}_setupFilterTextures(e,t,r,i){if(e.backTexture=s.EMPTY,e.inputTexture=u.getOptimalTexture(t.width,t.height,e.resolution,e.antialias),e.blendRequired){r.renderTarget.finishRenderPass();const n=r.renderTarget.getRenderTarget(e.outputRenderSurface);e.backTexture=this.getBackTexture(n,t,i?.bounds)}r.renderTarget.bind(e.inputTexture,!0),r.globalUniforms.push({offset:t})}_calculateGlobalFrame(e,t,r,i,n,o){const u=e.globalFrame;u.x=t*i,u.y=r*i,u.width=n*i,u.height=o*i}_updateFilterUniforms(e,t,r,i,n,o,u,a){const l=this._filterGlobalUniforms.uniforms,c=l.uOutputFrame,d=l.uInputSize,p=l.uInputPixel,f=l.uInputClamp,h=l.uGlobalFrame,x=l.uOutputTexture;u?(c[0]=r.bounds.minX-i,c[1]=r.bounds.minY-n):(c[0]=0,c[1]=0),c[2]=e.frame.width,c[3]=e.frame.height,d[0]=e.source.width,d[1]=e.source.height,d[2]=1/d[0],d[3]=1/d[1],p[0]=e.source.pixelWidth,p[1]=e.source.pixelHeight,p[2]=1/p[0],p[3]=1/p[1],f[0]=.5*p[2],f[1]=.5*p[3],f[2]=e.frame.width*d[2]-.5*p[2],f[3]=e.frame.height*d[3]-.5*p[3];const m=this.renderer.renderTarget.rootRenderTarget.colorTexture;h[0]=i*o,h[1]=n*o,h[2]=m.source.width*o,h[3]=m.source.height*o,t instanceof s&&(t.source.resource=null);const g=this.renderer.renderTarget.getRenderTarget(t);this.renderer.renderTarget.bind(t,!!a),t instanceof s?(x[0]=t.frame.width,x[1]=t.frame.height):(x[0]=g.width,x[1]=g.height),x[2]=g.isRoot?-1:1,this._filterGlobalUniforms.update()}_findFilterResolution(e){let t=this._filterStackIndex-1;for(;t>0&&this._filterStack[t].skip;)--t;return t>0&&this._filterStack[t].inputTexture?this._filterStack[t].inputTexture.source._resolution:e}_findPreviousFilterOffset(){let e=0,t=0,r=this._filterStackIndex;for(;r>0;){r--;const i=this._filterStack[r];if(!i.skip){e=i.bounds.minX,t=i.bounds.minY;break}}return{x:e,y:t}}_calculateFilterArea(e,t){if(e.renderables?function(e,t){t.clear();const r=t.matrix;for(let i=0;i<e.length;i++){const r=e[i];if(r.globalDisplayStatus<7)continue;const n=r.renderGroup??r.parentRenderGroup;t.matrix=n?.isCachedAsTexture?g.copyFrom(n.textureOffsetInverseTransform).append(r.worldTransform):n?._parentCacheAsTextureRenderGroup?g.copyFrom(n._parentCacheAsTextureRenderGroup.inverseWorldTransform).append(r.groupTransform):r.worldTransform,t.addBounds(r.bounds)}t.matrix=r}(e.renderables,t):e.filterEffect.filterArea?(t.clear(),t.addRect(e.filterEffect.filterArea),t.applyMatrix(e.container.worldTransform)):e.container.getFastGlobalBounds(!0,t),e.container){const r=(e.container.renderGroup||e.container.parentRenderGroup).cacheToLocalTransform;r&&t.applyMatrix(r)}}_applyFiltersToTexture(e,t){const r=e.inputTexture,i=e.bounds,n=e.filters,o=e.firstEnabledIndex,s=e.lastEnabledIndex;if(this._globalFilterBindGroup.setResource(r.source.style,2),this._globalFilterBindGroup.setResource(e.backTexture.source,3),o===s)n[o].apply(this,r,e.outputRenderSurface,t);else{let r=e.inputTexture;const a=u.getOptimalTexture(i.width,i.height,r.source._resolution,!1);let l=a;for(let e=o;e<s;e++){const t=n[e];if(!t.enabled)continue;t.apply(this,r,l,!0);const i=r;r=l,l=i}n[s].apply(this,r,e.outputRenderSurface,t),u.returnTexture(a)}}_calculateFilterBounds(e,t,r,i,n){const o=this.renderer,u=e.bounds,s=e.filters;let a=1/0,l=0,d=!0,p=!1,f=!1,h=!0,x=-1,m=-1;for(let g=0;g<s.length;g++){const e=s[g];if(!e.enabled)continue;-1===x&&(x=g),m=g,a=Math.min(a,"inherit"===e.resolution?i:e.resolution),l+=e.padding,"off"===e.antialias?d=!1:"inherit"===e.antialias&&d&&(d=r),e.clipToViewport||(h=!1);if(!!!(e.compatibleRenderers&o.type)){f=!1;break}if(e.blendRequired&&!(o.backBuffer?.useBackBuffer??1)){c("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options."),f=!1;break}f=!0,p||(p=e.blendRequired)}f?(h&&u.fitBounds(0,t.width/i,0,t.height/i),u.scale(a).ceil().scale(1/a).pad((0|l)*n),u.isPositive?(e.antialias=d,e.resolution=a,e.blendRequired=p,e.firstEnabledIndex=x,e.lastEnabledIndex=m):e.skip=!0):e.skip=!0}_popFilterData(){return this._filterStackIndex--,this._filterStack[this._filterStackIndex]}_getPreviousFilterData(){let e,t=this._filterStackIndex-1;for(;t>0&&(t--,e=this._filterStack[t],e.skip););return e}_pushFilterData(){let e=this._filterStack[this._filterStackIndex];return e||(e=this._filterStack[this._filterStackIndex]=new b),this._filterStackIndex++,e}}_.extension={type:[r.WebGLSystem,r.WebGPUSystem],name:"filter"},p.add(_),p.add(m);
