import{D as e,C as t,f as n,h as a,m as r,M as o,i as s,j as i,w as c,T as l,k as h,s as d,l as u,F as p,n as g,o as m,A as x,R as f,p as v}from"./index-HTzhn4j5.js";import{R as y,S as C,B as _,a as w,b as T,c as b,A as M,C as k}from"./RenderTargetSystem-hu5syUo4.js";import"./ui-vendor-CvsVdvUW.js";import"./react-vendor-QThkW06V.js";import"./chart-vendor-DnBxnkJV.js";import"./editor-vendor-C3mMr2U9.js";import"./utils-vendor-C-gIm3of.js";import"./docx-BJa0GThP.js";import"./Filter-DuZZ3SNw.js";let I;function P(t){const n=e.get().createCanvas(6,1),a=n.getContext("2d");return a.fillStyle=t,a.fillRect(0,0,6,1),n}function S(){if(void 0!==I)return I;try{const t=P("#ff00ff"),n=P("#ffff00"),a=e.get().createCanvas(6,1).getContext("2d");a.globalCompositeOperation="multiply",a.drawImage(t,0,0),a.drawImage(n,2,0);const r=a.getImageData(2,0,1,1);if(r){const e=r.data;I=255===e[0]&&0===e[1]&&0===e[2]}else I=!1}catch(t){I=!1}return I}const R={canvas:null,convertTintToImage:!1,cacheStepsPerColorChannel:8,canUseMultiply:S(),tintMethod:null,_canvasSourceCache:new WeakMap,_unpremultipliedCache:new WeakMap,getCanvasSource:t=>{const n=t.source,a=n?.resource;if(!a)return null;const r="premultiplied-alpha"===n.alphaMode,o=n.resourceWidth??n.pixelWidth,s=n.resourceHeight??n.pixelHeight,i=o!==n.pixelWidth||s!==n.pixelHeight;if(r){if((a instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&a instanceof OffscreenCanvas)&&!i)return a;const e=R._unpremultipliedCache.get(n);if(e?.resourceId===n._resourceId)return e.canvas}if(a instanceof Uint8Array||a instanceof Uint8ClampedArray||a instanceof Int8Array||a instanceof Uint16Array||a instanceof Int16Array||a instanceof Uint32Array||a instanceof Int32Array||a instanceof Float32Array||a instanceof ArrayBuffer){const t=R._canvasSourceCache.get(n);if(t?.resourceId===n._resourceId)return t.canvas;const r=e.get().createCanvas(n.pixelWidth,n.pixelHeight),o=r.getContext("2d"),s=o.createImageData(n.pixelWidth,n.pixelHeight),i=s.data,c=a instanceof ArrayBuffer?new Uint8Array(a):new Uint8Array(a.buffer,a.byteOffset,a.byteLength);if("bgra8unorm"===n.format)for(let e=0;e<i.length&&e+3<c.length;e+=4)i[e]=c[e+2],i[e+1]=c[e+1],i[e+2]=c[e],i[e+3]=c[e+3];else i.set(c.subarray(0,i.length));return o.putImageData(s,0,0),R._canvasSourceCache.set(n,{canvas:r,resourceId:n._resourceId}),r}if(r){const t=e.get().createCanvas(n.pixelWidth,n.pixelHeight),r=t.getContext("2d",{willReadFrequently:!0});t.width=n.pixelWidth,t.height=n.pixelHeight,r.drawImage(a,0,0);const o=r.getImageData(0,0,t.width,t.height),s=o.data;for(let e=0;e<s.length;e+=4){const t=s[e+3];if(t>0){const n=255/t;s[e]=Math.min(255,s[e]*n+.5),s[e+1]=Math.min(255,s[e+1]*n+.5),s[e+2]=Math.min(255,s[e+2]*n+.5)}}return r.putImageData(o,0,0),R._unpremultipliedCache.set(n,{canvas:t,resourceId:n._resourceId}),t}if(i){const t=R._canvasSourceCache.get(n);if(t?.resourceId===n._resourceId)return t.canvas;const r=e.get().createCanvas(n.pixelWidth,n.pixelHeight),o=r.getContext("2d");return r.width=n.pixelWidth,r.height=n.pixelHeight,o.drawImage(a,0,0),R._canvasSourceCache.set(n,{canvas:r,resourceId:n._resourceId}),r}return a},getTintedCanvas:(n,a)=>{const r=n.texture,o=t.shared.setValue(a).toHex(),s=r.tintCache||(r.tintCache={}),i=s[o],c=r.source._resourceId;if(i?.tintId===c)return i;const l=i&&"getContext"in i?i:e.get().createCanvas();return R.tintMethod(r,a,l),l.tintId=c,s[o]=l,s[o]},getTintedPattern:(n,a)=>{const r=t.shared.setValue(a).toHex(),o=n.patternCache||(n.patternCache={}),s=n.source._resourceId;let i=o[r];if(i?.tintId===s)return i;R.canvas||(R.canvas=e.get().createCanvas()),R.tintMethod(n,a,R.canvas);return i=R.canvas.getContext("2d").createPattern(R.canvas,"repeat"),i.tintId=s,o[r]=i,i},applyPatternTransform:(e,t,n=!0)=>{if(!t)return;const a=e;if(!a.setTransform)return;const r=globalThis.DOMMatrix;if(!r)return;const o=new r([t.a,t.b,t.c,t.d,t.tx,t.ty]);a.setTransform(n?o.inverse():o)},tintWithMultiply:(e,a,r)=>{const o=r.getContext("2d"),s=e.frame.clone(),i=e.source._resolution??e.source.resolution??1,c=e.rotate;s.x*=i,s.y*=i,s.width*=i,s.height*=i;const l=n.isVertical(c),h=l?s.height:s.width,d=l?s.width:s.height;r.width=Math.ceil(h),r.height=Math.ceil(d),o.save(),o.fillStyle=t.shared.setValue(a).toHex(),o.fillRect(0,0,h,d),o.globalCompositeOperation="multiply";const u=R.getCanvasSource(e);u?(c&&R._applyInverseRotation(o,c,s.width,s.height),o.drawImage(u,s.x,s.y,s.width,s.height,0,0,s.width,s.height),o.globalCompositeOperation="destination-atop",o.drawImage(u,s.x,s.y,s.width,s.height,0,0,s.width,s.height),o.restore()):o.restore()},tintWithOverlay:(e,a,r)=>{const o=r.getContext("2d"),s=e.frame.clone(),i=e.source._resolution??e.source.resolution??1,c=e.rotate;s.x*=i,s.y*=i,s.width*=i,s.height*=i;const l=n.isVertical(c),h=l?s.height:s.width,d=l?s.width:s.height;r.width=Math.ceil(h),r.height=Math.ceil(d),o.save(),o.globalCompositeOperation="copy",o.fillStyle=t.shared.setValue(a).toHex(),o.fillRect(0,0,h,d),o.globalCompositeOperation="destination-atop";const u=R.getCanvasSource(e);u?(c&&R._applyInverseRotation(o,c,s.width,s.height),o.drawImage(u,s.x,s.y,s.width,s.height,0,0,s.width,s.height),o.restore()):o.restore()},tintWithPerPixel:(e,t,a)=>{const r=a.getContext("2d"),o=e.frame.clone(),s=e.source._resolution??e.source.resolution??1,i=e.rotate;o.x*=s,o.y*=s,o.width*=s,o.height*=s;const c=n.isVertical(i),l=c?o.height:o.width,h=c?o.width:o.height;a.width=Math.ceil(l),a.height=Math.ceil(h),r.save(),r.globalCompositeOperation="copy";const d=R.getCanvasSource(e);if(!d)return void r.restore();i&&R._applyInverseRotation(r,i,o.width,o.height),r.drawImage(d,o.x,o.y,o.width,o.height,0,0,o.width,o.height),r.restore();const u=t>>16&255,p=t>>8&255,g=255&t,m=r.getImageData(0,0,l,h),x=m.data;for(let n=0;n<x.length;n+=4)x[n]=x[n]*u/255,x[n+1]=x[n+1]*p/255,x[n+2]=x[n+2]*g/255;r.putImageData(m,0,0)},_applyInverseRotation:(e,t,a,r)=>{const o=n.inv(t),s=n.uX(o),i=n.uY(o),c=n.vX(o),l=n.vY(o),h=-Math.min(0,s*a,c*r,s*a+c*r),d=-Math.min(0,i*a,l*r,i*a+l*r);e.transform(s,i,c,l,h,d)}};R.tintMethod=R.canUseMultiply?R.tintWithMultiply:R.tintWithPerPixel;const A=class e{static _getPatternRepeat(e,t){const n=e&&"clamp-to-edge"!==e,a=t&&"clamp-to-edge"!==t;return n&&a?"repeat":n?"repeat-x":a?"repeat-y":"no-repeat"}start(e,t,n){}execute(t,o){const s=o.elements;if(!s||!s.length)return;const i=t.renderer,c=i.canvasContext,l=c.activeContext;for(let h=0;h<s.length;h++){const t=s[h];if(!t.packAsQuad)continue;const d=t,u=d.texture,p=u?R.getCanvasSource(u):null;if(!p)continue;const g=u.source.style,m=c.smoothProperty,x="nearest"!==g.scaleMode;l[m]!==x&&(l[m]=x),c.setBlendMode(o.blendMode);const f=i.globalUniforms.globalUniformData?.worldColor??4294967295,v=d.color,y=(f>>>24&255)/255*((v>>>24&255)/255)*(i.filter?.alphaMultiplier??1);if(y<=0)continue;l.globalAlpha=y;const C=a(r(16777215&v,16777215&f)),_=u.frame,w=g.addressModeU??g.addressMode,T=g.addressModeV??g.addressMode,b=e._getPatternRepeat(w,T),M=u.source._resolution??u.source.resolution??1,k=d.renderable?.renderGroup?.isCachedAsTexture,I=_.x*M,P=_.y*M,S=_.width*M,A=_.height*M,W=d.bounds,H=i.renderTarget.renderTarget.isRoot,B=W.minX,O=W.minY,D=W.maxX-W.minX,E=W.maxY-W.minY,U=u.rotate,j=u.uvs,F=Math.min(j.x0,j.x1,j.x2,j.x3,j.y0,j.y1,j.y2,j.y3),V=Math.max(j.x0,j.x1,j.x2,j.x3,j.y0,j.y1,j.y2,j.y3),q="no-repeat"!==b&&(F<0||V>1),G=U&&!(!q&&(16777215!==C||U));G?(e._tempPatternMatrix.copyFrom(d.transform),n.matrixAppendRotationInv(e._tempPatternMatrix,U,B,O,D,E),c.setContextTransform(e._tempPatternMatrix,1===d.roundPixels,void 0,k&&H)):c.setContextTransform(d.transform,1===d.roundPixels,void 0,k&&H);const L=G?0:B,Y=G?0:O,N=D,X=E;if(q){let t=p;const n=16777215!==C&&!U,a=_.width<=u.source.width&&_.height<=u.source.height;n&&a&&(t=R.getTintedCanvas({texture:u},C));const r=l.createPattern(t,b);if(!r)continue;const o=N,s=X;if(0===o||0===s)continue;const i=1/o,c=1/s,h=(j.x1-j.x0)*i,d=(j.y1-j.y0)*i,g=(j.x3-j.x0)*c,m=(j.y3-j.y0)*c,x=j.x0-h*L-g*Y,f=j.y0-d*L-m*Y,v=u.source.pixelWidth,y=u.source.pixelHeight;e._tempPatternMatrix.set(h*v,d*y,g*v,m*y,x*v,f*y),R.applyPatternTransform(r,e._tempPatternMatrix),l.fillStyle=r,l.fillRect(L,Y,N,X)}else{const e=16777215!==C||U?R.getTintedCanvas({texture:u},C):p,t=e!==p;l.drawImage(e,t?0:I,t?0:P,t?e.width:S,t?e.height:A,L,Y,N,X)}}}};A._tempPatternMatrix=new o,A.extension={type:[s.CanvasPipesAdaptor],name:"batch"};let W=A;class H{constructor(e){this._colorStack=[],this._colorStackIndex=0,this._currentColor=0,this._renderer=e}buildStart(){this._colorStack[0]=15,this._colorStackIndex=1,this._currentColor=15}push(e,t,n){this._renderer.renderPipes.batch.break(n);const a=this._colorStack;a[this._colorStackIndex]=a[this._colorStackIndex-1]&e.mask;const r=this._colorStack[this._colorStackIndex];r!==this._currentColor&&(this._currentColor=r,n.add({renderPipeId:"colorMask",colorMask:r,canBundle:!1})),this._colorStackIndex++}pop(e,t,n){this._renderer.renderPipes.batch.break(n);const a=this._colorStack;this._colorStackIndex--;const r=a[this._colorStackIndex-1];r!==this._currentColor&&(this._currentColor=r,n.add({renderPipeId:"colorMask",colorMask:r,canBundle:!1}))}execute(e){}destroy(){this._renderer=null,this._colorStack=null}}function B(e,t){switch(t.type){case"rectangle":{const n=t;e.rect(n.x,n.y,n.width,n.height);break}case"roundedRectangle":{const n=t;!function(e,t,n,a,r,o){o=Math.max(0,Math.min(o,Math.min(a,r)/2)),e.moveTo(t+o,n),e.lineTo(t+a-o,n),e.quadraticCurveTo(t+a,n,t+a,n+o),e.lineTo(t+a,n+r-o),e.quadraticCurveTo(t+a,n+r,t+a-o,n+r),e.lineTo(t+o,n+r),e.quadraticCurveTo(t,n+r,t,n+r-o),e.lineTo(t,n+o),e.quadraticCurveTo(t,n,t+o,n)}(e,n.x,n.y,n.width,n.height,n.radius);break}case"circle":{const n=t;e.moveTo(n.x+n.radius,n.y),e.arc(n.x,n.y,n.radius,0,2*Math.PI);break}case"ellipse":{const n=t;e.ellipse?(e.moveTo(n.x+n.halfWidth,n.y),e.ellipse(n.x,n.y,n.halfWidth,n.halfHeight,0,0,2*Math.PI)):(e.save(),e.translate(n.x,n.y),e.scale(n.halfWidth,n.halfHeight),e.moveTo(1,0),e.arc(0,0,1,0,2*Math.PI),e.restore());break}case"triangle":{const n=t;e.moveTo(n.x,n.y),e.lineTo(n.x2,n.y2),e.lineTo(n.x3,n.y3),e.closePath();break}default:{const n=t,a=n.points;if(!a?.length)break;e.moveTo(a[0],a[1]);for(let t=2;t<a.length;t+=2)e.lineTo(a[t],a[t+1]);n.closePath&&e.closePath();break}}}function O(e,t){if(!t?.length)return!1;for(let n=0;n<t.length;n++){const a=t[n];if(!a?.shape)continue;const r=a.transform,o=r&&!r.isIdentity();o&&(e.save(),e.transform(r.a,r.b,r.c,r.d,r.tx,r.ty)),B(e,a.shape),o&&e.restore()}return!0}H.extension={type:[s.CanvasPipes],name:"colorMask"};class D{constructor(e){this._warnedMaskTypes=new Set,this._canvasMaskStack=[],this._renderer=e}push(e,t,n){this._renderer.renderPipes.batch.break(n),n.add({renderPipeId:"stencilMask",action:"pushMaskBegin",mask:e,inverse:t._maskOptions.inverse,canBundle:!1})}pop(e,t,n){this._renderer.renderPipes.batch.break(n),n.add({renderPipeId:"stencilMask",action:"popMaskEnd",mask:e,inverse:t._maskOptions.inverse,canBundle:!1})}execute(e){if("pushMaskBegin"!==e.action&&"popMaskEnd"!==e.action)return;const t=this._renderer,n=t.canvasContext,a=n?.activeContext;if(!a)return;if("popMaskEnd"===e.action){return void(this._canvasMaskStack.pop()&&a.restore())}e.inverse&&this._warnOnce("inverse","CanvasRenderer: inverse masks are not supported on Canvas2D; ignoring inverse flag.");const r=e.mask.mask;if(!(r instanceof i))return this._warnOnce("nonGraphics","CanvasRenderer: only Graphics masks are supported in Canvas2D; skipping mask."),void this._canvasMaskStack.push(!1);const o=r,s=o.context?.instructions;if(!s?.length)return void this._canvasMaskStack.push(!1);a.save(),n.setContextTransform(o.groupTransform,1===(t._roundPixels|o._roundPixels)),a.beginPath();let c=!1,l=!1;for(let i=0;i<s.length;i++){const e=s[i],t=e.action;if("fill"!==t&&"stroke"!==t)continue;const n=e.data,r=n?.path?.shapePath;if(!r?.shapePrimitives?.length)continue;const o=r.shapePrimitives;for(let s=0;s<o.length;s++){const e=o[s];if(!e?.shape)continue;const t=e.transform,n=t&&!t.isIdentity();n&&(a.save(),a.transform(t.a,t.b,t.c,t.d,t.tx,t.ty)),B(a,e.shape),l=O(a,e.holes)||l,c=!0,n&&a.restore()}}if(!c)return a.restore(),void this._canvasMaskStack.push(!1);l?a.clip("evenodd"):a.clip(),this._canvasMaskStack.push(!0)}destroy(){this._renderer=null,this._warnedMaskTypes=null,this._canvasMaskStack=null}_warnOnce(e,t){this._warnedMaskTypes.has(e)||(this._warnedMaskTypes.add(e),c(t))}}D.extension={type:[s.CanvasPipes],name:"stencilMask"};const E="source-over";const U=new o;class j{constructor(e){this.activeResolution=1,this.smoothProperty="imageSmoothingEnabled",this.blendModes=function(){const e=S(),t=Object.create(null);return t.inherit=E,t.none=E,t.normal="source-over",t.add="lighter",t.multiply=e?"multiply":E,t.screen=e?"screen":E,t.overlay=e?"overlay":E,t.darken=e?"darken":E,t.lighten=e?"lighten":E,t["color-dodge"]=e?"color-dodge":E,t["color-burn"]=e?"color-burn":E,t["hard-light"]=e?"hard-light":E,t["soft-light"]=e?"soft-light":E,t.difference=e?"difference":E,t.exclusion=e?"exclusion":E,t.saturation=e?"saturation":E,t.color=e?"color":E,t.luminosity=e?"luminosity":E,t["linear-burn"]=e?"color-burn":E,t["linear-dodge"]=e?"color-dodge":E,t["linear-light"]=e?"hard-light":E,t["pin-light"]=e?"hard-light":E,t["vivid-light"]=e?"hard-light":E,t["hard-mix"]=E,t.negation=e?"difference":E,t["normal-npm"]=t.normal,t["add-npm"]=t.add,t["screen-npm"]=t.screen,t.erase="destination-out",t.subtract=E,t.divide=E,t.min=E,t.max=E,t}(),this._activeBlendMode="normal",this._projTransform=null,this._outerBlend=!1,this._warnedBlendModes=new Set,this._renderer=e}resolutionChange(e){this.activeResolution=e}init(){const e=this._renderer.background.alpha<1;if(this.rootContext=this._renderer.canvas.getContext("2d",{alpha:e}),this.activeContext=this.rootContext,this.activeResolution=this._renderer.resolution,!this.rootContext.imageSmoothingEnabled){const e=this.rootContext;e.webkitImageSmoothingEnabled?this.smoothProperty="webkitImageSmoothingEnabled":e.mozImageSmoothingEnabled?this.smoothProperty="mozImageSmoothingEnabled":e.oImageSmoothingEnabled?this.smoothProperty="oImageSmoothingEnabled":e.msImageSmoothingEnabled&&(this.smoothProperty="msImageSmoothingEnabled")}}setContextTransform(e,t,n,a){const r=a?o.IDENTITY:this._renderer.globalUniforms.globalUniformData?.worldTransformMatrix||o.IDENTITY;let s=U;s.copyFrom(r),s.append(e);const i=this._projTransform,c=this.activeResolution;if(n=n||c,i){const e=o.shared;e.copyFrom(s),e.prepend(i),s=e}t?this.activeContext.setTransform(s.a*n,s.b*n,s.c*n,s.d*n,s.tx*c|0,s.ty*c|0):this.activeContext.setTransform(s.a*n,s.b*n,s.c*n,s.d*n,s.tx*c,s.ty*c)}clear(e,n){const a=this.activeContext,r=this._renderer;if(a.clearRect(0,0,r.width,r.height),e){const o=t.shared.setValue(e);a.globalAlpha=n??o.alpha,a.fillStyle=o.toHex(),a.fillRect(0,0,r.width,r.height),a.globalAlpha=1}}setBlendMode(e){if(this._activeBlendMode===e)return;this._activeBlendMode=e,this._outerBlend=!1;const t=this.blendModes[e];if(!t)return this._warnedBlendModes.has(e)||(console.warn(`CanvasRenderer: blend mode "${e}" is not supported in Canvas2D; falling back to "source-over".`),this._warnedBlendModes.add(e)),void(this.activeContext.globalCompositeOperation="source-over");this.activeContext.globalCompositeOperation=t}destroy(){this.rootContext=null,this.activeContext=null,this._warnedBlendModes.clear()}}j.extension={type:[s.CanvasSystem],name:"canvasContext"};class F{constructor(){this.maxTextures=16,this.maxBatchableTextures=16,this.maxUniformBindings=0}init(){}}F.extension={type:[s.CanvasSystem],name:"limits"};const V=new o,q=new o,G=new o,L=new o;function Y(e,t,n){e.beginPath();for(let a=0;a<n.length;a+=3){const r=2*n[a],o=2*n[a+1],s=2*n[a+2];e.moveTo(t[r],t[r+1]),e.lineTo(t[o],t[o+1]),e.lineTo(t[s],t[s+1]),e.closePath()}e.fill()}function N(e,t){switch(t.type){case"rectangle":{const n=t;e.rect(n.x,n.y,n.width,n.height);break}case"roundedRectangle":{const n=t;!function(e,t,n,a,r,o){o=Math.max(0,Math.min(o,Math.min(a,r)/2)),e.moveTo(t+o,n),e.lineTo(t+a-o,n),e.quadraticCurveTo(t+a,n,t+a,n+o),e.lineTo(t+a,n+r-o),e.quadraticCurveTo(t+a,n+r,t+a-o,n+r),e.lineTo(t+o,n+r),e.quadraticCurveTo(t,n+r,t,n+r-o),e.lineTo(t,n+o),e.quadraticCurveTo(t,n,t+o,n)}(e,n.x,n.y,n.width,n.height,n.radius);break}case"circle":{const n=t;e.arc(n.x,n.y,n.radius,0,2*Math.PI);break}case"ellipse":{const n=t;e.ellipse?e.ellipse(n.x,n.y,n.halfWidth,n.halfHeight,0,0,2*Math.PI):(e.save(),e.translate(n.x,n.y),e.scale(n.halfWidth,n.halfHeight),e.arc(0,0,1,0,2*Math.PI),e.restore());break}case"triangle":{const n=t;e.moveTo(n.x,n.y),e.lineTo(n.x2,n.y2),e.lineTo(n.x3,n.y3),e.closePath();break}default:{const n=t,a=n.points;if(!a?.length)break;e.moveTo(a[0],a[1]);for(let t=2;t<a.length;t+=2)e.lineTo(a[t],a[t+1]);n.closePath&&e.closePath();break}}}function X(e,t){if(!t?.length)return!1;for(let n=0;n<t.length;n++){const a=t[n];if(!a?.shape)continue;const r=a.transform,o=r&&!r.isIdentity();o&&(e.save(),e.transform(r.a,r.b,r.c,r.d,r.tx,r.ty)),N(e,a.shape),o&&e.restore()}return!0}function z(e,t,n,a){const r=e.fill;if(r instanceof p){r.buildGradient();const o=r.texture;if(o){const s=R.getTintedPattern(o,t),i=n?L.copyFrom(n).scale(o.source.pixelWidth,o.source.pixelHeight):L.copyFrom(r.transform);return a&&!e.textureSpace&&i.append(a),R.applyPatternTransform(s,i),s}}if(r instanceof g){const e=R.getTintedPattern(r.texture,t);return R.applyPatternTransform(e,r.transform),e}const o=e.texture;if(o&&o!==l.WHITE){if(!o.source.resource)return"#808080";const a=R.getTintedPattern(o,t),r=n?L.copyFrom(n).scale(o.source.pixelWidth,o.source.pixelHeight):e.matrix;return R.applyPatternTransform(a,r),a}return`#${(16777215&t).toString(16).padStart(6,"0")}`}class ${constructor(){this.shader=null}contextChange(e){}execute(e,t){const o=e.renderer,s=o.canvasContext,i=s.activeContext,c=t.groupTransform,p=o.globalUniforms.globalUniformData?.worldColor??4294967295,g=t.groupColorAlpha,m=(p>>>24&255)/255*((g>>>24&255)/255)*(o.filter?.alphaMultiplier??1);if(m<=0)return;const x=a(r(16777215&g,16777215&p)),f=o._roundPixels|t._roundPixels;i.save(),s.setContextTransform(c,1===f),s.setBlendMode(t.groupBlendMode);const v=t.context.instructions;for(let a=0;a<v.length;a++){const e=v[a];if("texture"===e.action){const t=e.data,a=t.image,o=a?R.getCanvasSource(a):null;if(!o)continue;const l=t.alpha*m;if(l<=0)continue;const h=r(t.style,x);i.globalAlpha=l;let d=o;16777215!==h&&(d=R.getTintedCanvas({texture:a},h));const u=a.frame,p=a.source._resolution??a.source.resolution??1;let g=u.x*p,v=u.y*p;const y=u.width*p,C=u.height*p;d!==o&&(g=0,v=0);const _=t.transform,w=_&&!_.isIdentity(),T=a.rotate;w||T?(V.copyFrom(c),w&&V.append(_),T&&n.matrixAppendRotationInv(V,T,t.dx,t.dy,t.dw,t.dh),s.setContextTransform(V,1===f)):s.setContextTransform(c,1===f),i.drawImage(d,g,v,d===o?y:d.width,d===o?C:d.height,T?0:t.dx,T?0:t.dy,t.dw,t.dh),(w||T)&&s.setContextTransform(c,1===f);continue}const t=e.data,o=t?.path?.shapePath;if(!o?.shapePrimitives?.length)continue;const p=t.style,g=r(p.color,x),y=p.alpha*m;if(y<=0)continue;const C="stroke"===e.action;if(i.globalAlpha=y,C){const e=p;i.lineWidth=e.width,i.lineCap=e.cap,i.lineJoin=e.join,i.miterLimit=e.miterLimit}const _=o.shapePrimitives;if(!C&&t.hole?.shapePath?.shapePrimitives?.length){_[_.length-1].holes=t.hole.shapePath.shapePrimitives}for(let n=0;n<_.length;n++){const e=_[n];if(!e?.shape)continue;const t=e.transform,a=t&&!t.isIdentity(),r=p.texture&&p.texture!==l.WHITE,o="global"===p.textureSpace?t:null,s=z(p,g,r?h(q,p,e.shape,o):null,a?G.copyFrom(c).append(t):c);if(a&&(i.save(),i.transform(t.a,t.b,t.c,t.d,t.tx,t.ty)),C){const t=p;if(.5!==t.alignment&&!t.pixelLine){const n=[],a=[],r=[],o=d[e.shape.type];if(o?.build(e.shape,n)){const o=e.shape.closePath??!0;u(n,t,!1,o,a,r),i.fillStyle=s,Y(i,a,r)}else i.strokeStyle=s,i.beginPath(),N(i,e.shape),i.stroke()}else i.strokeStyle=s,i.beginPath(),N(i,e.shape),i.stroke()}else{i.fillStyle=s,i.beginPath(),N(i,e.shape);X(i,e.holes)?i.fill("evenodd"):i.fill()}a&&i.restore()}}i.restore()}destroy(){this.shader=null}}$.extension={type:[s.CanvasPipesAdaptor],name:"graphics"};class J{init(e,t){this._renderer=e,this._renderTargetSystem=t}initGpuRenderTarget(e){const t=e.colorTexture,{canvas:n,context:a}=this._ensureCanvas(t);return{canvas:n,context:a,width:n.width,height:n.height}}resizeGpuRenderTarget(e){const t=e.colorTexture,{canvas:n}=this._ensureCanvas(t);n.width=e.pixelWidth,n.height=e.pixelHeight}startRenderPass(e,t,n,a){const r=this._renderTargetSystem.getGpuRenderTarget(e);this._renderer.canvasContext.activeContext=r.context,this._renderer.canvasContext.activeResolution=e.resolution,t&&this.clear(e,t,n,a)}clear(e,n,a,r){const o=this._renderTargetSystem.getGpuRenderTarget(e).context,s=r||{x:0,y:0,width:e.pixelWidth,height:e.pixelHeight};if(o.setTransform(1,0,0,1,0,0),o.clearRect(s.x,s.y,s.width,s.height),a){const e=t.shared.setValue(a);e.alpha>0&&(o.globalAlpha=e.alpha,o.fillStyle=e.toHex(),o.fillRect(s.x,s.y,s.width,s.height),o.globalAlpha=1)}}finishRenderPass(){}copyToTexture(e,t,n,a,r){const o=this._renderTargetSystem.getGpuRenderTarget(e).canvas,s=t.source,{context:i}=this._ensureCanvas(s),c=r?.x??0,l=r?.y??0;return i.drawImage(o,n.x,n.y,a.width,a.height,c,l,a.width,a.height),s.update(),t}destroyGpuRenderTarget(e){}_ensureCanvas(t){let n=t.resource;n&&m.test(n)||(n=e.get().createCanvas(t.pixelWidth,t.pixelHeight),t.resource=n),n.width===t.pixelWidth&&n.height===t.pixelHeight||(n.width=t.pixelWidth,n.height=t.pixelHeight);const a=n.getContext("2d");return{canvas:n,context:a}}}class Q extends y{constructor(e){super(e),this.adaptor=new J,this.adaptor.init(e,this)}}Q.extension={type:[s.CanvasSystem],name:"renderTarget"};class K{constructor(e){}init(){}initSource(e){}generateCanvas(t){const n=e.get().createCanvas(),a=n.getContext("2d"),r=R.getCanvasSource(t);if(!r)return n;const o=t.frame,s=t.source._resolution??t.source.resolution??1,i=o.x*s,c=o.y*s,l=o.width*s,h=o.height*s;return n.width=Math.ceil(l),n.height=Math.ceil(h),a.drawImage(r,i,c,l,h,0,0,l,h),n}getPixels(e){const t=this.generateCanvas(e);return{pixels:t.getContext("2d",{willReadFrequently:!0}).getImageData(0,0,t.width,t.height).data,width:t.width,height:t.height}}destroy(){}}K.extension={type:[s.CanvasSystem],name:"texture"};const Z=[...C,j,F,K,Q],ee=[_,w,T,b,M,D,H,k],te=[W,$],ne=[],ae=[],re=[];v.handleByNamedList(s.CanvasSystem,ne),v.handleByNamedList(s.CanvasPipes,ae),v.handleByNamedList(s.CanvasPipesAdaptor,re),v.add(...Z,...ee,...te);class oe extends x{constructor(){super({name:"canvas",type:f.CANVAS,systems:ne,renderPipes:ae,renderPipeAdaptors:re})}}export{oe as CanvasRenderer};
